# How I learned to stop worrying and love the chaos

*(Two points to anyone who catches the Kubrick reference.)*

**Abstract:** I know I want to communicate computing science (CS) and software engineering (SE).
Although I have sense there's appetite for this kind of thing, I don't know where to begin -- especially with YouTube
full of perfectly excellent seminars if you know how to look. To explore the problem space, I (plan to) conduct
surveys and focus groups with three main groups of stakeholders in the (local corporate) tech team:
junior programmers (to identify desire), senior/team-lead programmers (to sense need),
and the non-programnming local-executive staff (to peek over the horizon and align key objectives). Additionally,
I network through experienced contacts to drum up both venue and interest.
Results are %TOPIC% and %TOPIC% have the intersection of interest and need: After boning up on both,
presentations at %VENUE% and %VENUE% resulted in %NUMBER% attendees giving a "will use often" review rating.
One month and three months later, follow-up measures of the original senior/team-lead cohort reaveal %X% percent
improvement on seven-point Likert scale surveys of organizational performance along dimensions X, Y, and Z.

## Introduction

As an aspiring famous-person, it's easy to fall prey to one's own hubris and forget to do the hard work involved.
Famous in what way? *So glad you asked.* Technical communication influencer. I want to do this. I think we need it,
and I *will* find ways to make my contributions relevant, even if I have to crash a few gates in the process.

The [Five Gates of Implementation](http://thecodelesscode.com/case/78) generalize quite naturally to suggest a
sensibly-conservative approach to more things than code -- technical communication included.
But as George Bernard Shaw [pointed out](https://www.goodreads.com/quotes/536961),
it takes a bit of unreasoning passion to make headway in bettering the status quo.

*I have that passion.* I also have a long history with computing science (CS) and software engineering (SE): some book-learning, and some practical.
What's in it for me personally is a lot of things. Yes, rewarding interpersonal connections are on that list
*(and why shouldn't they be?)* but also a connection between career and a higher purpose,
leading to a measure of [Self-actualization](https://en.wikipedia.org/wiki/Self-actualization).

What I do not have *yet,* prior to completing the conceptual studies laid out in this paper,
is a clear plan of attack.

Therefore, the rest of this paper is my plan/forecast/actual retrospective -- laid out in advance --
of how I get the background knowledge necessary to make an effective stab at
doing the real aim of the game, which is to convey what knowledge and wisdom I can to a receptive next generation.

*And furthermore,* if I can forge a more institutionalized path for *everyone* to get more communicative
about the good, bad, and ugly of CS and SE, then I will consider *that* some next-level success.

## The Obstacle Course: Feedback Loops of *Talent* and *Content*

> If technical public-speaking were easy, everyone would be doing it.

For the moment, let me invoke the [Copernican Principle](https://www.thoughtco.com/copernican-principle-2699117)
and its extension to the corporate domain: any difference between my own experience and the average is most likely
due more to statistical variation than any special significance of my position, so the balance of extrinsic influence
is probably largely similar for most.

> At this point, and because I haven't been living under a *complete* rock,
> I know that some fraction of the audience now has intense thoughts of systemic bias at center-stage.
> Here at _________, we do not tolerate workplace discrimination.
> Your mileage may vary, but if membership in an *EEO protected-class* contributes to that variation,
> then I am compelled to refer the matter to HR for resolution.
> If there are any further questions about this policy, please ask HR.

> This has been a public service announcement. I will now return to my topic.

As I was saying, the view from my vantage point is that our business partners (internal customers)
are most liberal with praise in connection with getting today's immediate problem solved,
or with making progress on whatever development project is current that day.

What that means is that, despite the availability of resources by which someone might sharpen the proverbial saw,
for most programming jobs the typical daily grind in no way stimulates such saw-sharpening,
much less the development of public-speaking skills or relevant topics to share.

This sets up a chicken-and-egg problem for aspiring speakers.
There is no cheat-code or royal road,
but existing technical speakers demonstrate conclusively that there *must* be a way in somehow.

So much for problems. Let's see about solutions.

## Prior Art / Prevailing Conception

**The Corporate Speaking Circuit:**
The company where I currently work periodically runs internal seminar programs consisting of
many presentations in a brief timespan all related to a common theme.

Although I know a few people who've spoken on this circuit,
I've yet to get any solid data on how one might go about joining it.
Anecdotes follow, though:

**Kevin** spoke as part of a coordinated, themed technical seminar which my current employer periodically orchestrates.

Roughly paraphrased, he said it fell into his lap in a *right-place right-time* serendipity:
He was asked to speak on topic XYZ, and he spoke.

Unfortunately, this contact provides very little direct usable guidance:
opportunities do not simply land in your lap without considerable advance preparation,
whether carefully planned or intuitively executed.

**James** periodically explains new features in a certain internal development platform,
along with other assorted speaking engagements.

I need to follow up with him for data -- or for anecdote. (At this point, I'll take either.)

**The Local Biweekly Forum:**
There is a biweekly horizontal application-specific knowledge-transfer session in Houston.
It usually consists of a rotation of technical topics.
I've actually given a presentation on the topic of my team's product in this venue once before.
My experience with venue in the past, both as audience and presenter,
suggests that it's been treated like elementary-school book reports:
Most of the audience lacks the context to make meaningful connections with what gets presented.

**Vaguely Similar Efforts:**
Luc tried to stimulate organic knowledge-transfer among members of a certain group of teams.
His method seemed like crowd-sourcing ideas for how to do software engineering well.
It lasted for a while, but seems to have either fizzled out or gone beneath my radar.
If I had to guess, it probably succumbed to the aforementioned systemic incentives
for people to keep their heads down and just produce code. Still, I should follow
up to find out what really happened.

## Approach / Methods / Solution

As [Bash≈ç tersely aludes,](https://www.goodreads.com/quotes/26897)
the point is not merely to go before an audience and speak words.
A proper audience expects and deserves to acheive a state of catharsis through their experience of those words.
The performer's role is to steer that catharsis towards the kind of personal and professional growth the audience signed up for.

The approach to, and effectiveness of, such a cathartic state is outside the scope of this paper.
Rather, I am presently focused on working out:

- which topics and venues are the most propitious;
- how to book space, generate buzz, and drive audiences; and
- how to measure impact.

Nevertheless, preparation's technique is inseparable from its necessity under the circumstances,
so I will not rule out discussion of that aspect of the experience or lessons thereby learned.

### Starting Points

On the specific topic of getting into the game of public speaking,
there are four obvious places to start.
These are drawn from observations made prior to any systemic attempt.

I know of one person
who's actually given one of these presentations. By personal communication, I asked him about
how he got involved. 

**The Local Biweekly Forum:**
As mentioned under *prior art*, the local forum is not especially glamorous at the moment,
but the people who control it are easy to work with.
Recently, all the usual topics had been used up, and it came out that more general topics might be welcome from time to time.
It sounds like I just have to propose a topic and I'll be given a 30-minute speaking engagement.


**Toastmasters International:**
You can't say "public speaking" without someone *speaking up* and mentioning Toastmasters.
I've had many good and enriching experiences with Toastmasters on previous occasions.
Some companies sponsor chapters, and some even make it a standard part of management training.

**Everyone Who Will Listen:**
The unconventional option is to start bending every willing ear to the nature of my plan,
in hopes of developing a network of zealots (or at least believers) who can 
help make the right connections on appeal to the law of large numbers.

### Early Progress

After a quick and disappointing look into the *Toastmasters* angle,
I quickly pivoted to *Everyone Who Will Listen.*
That naturally includes *The Local Biweekly Forum,*
and by extension Srilatha, who controls its schedule.

Once I worked up the gumption to explain my mission and ask her directly for time on the schedule,
she was quite receptive to the idea.
It was only necessary to make some concession to her sense of what could and should be presented.
She'd just recently done some informal polling herself: the intersection of supply and demand
showed my best first topic to be an introductory overview of _________, one of the company's
strategic platforms and one I'd accumulated over a year's direct experience with.

Having identified a topic, it was then necessary to organize an agenda.
The precise details are currently confidential, but in the abstract it
has roughly the structure I learned from the DOD's androgogy course.

As an early experiment with this agenda, I went over it with a new-hire.
That showed that, although I had a decent overall scope, I would need to add serious meat to the bones.
Thus, when I get back on Monday the plan is to expand in turn each major component of _________ to its own
sub-agenda following a simple formulaic plan. It might go like:

* Component
  * What problem it solves
  * Why this problem is worth solving
  * Approach to solution
  * Strength and weakness of the approach taken
  * Direct comparison to alternatives, if known
  * Surprises from experience with the component, if any
  * Where to find more information

This pattern can also be applied in advance to the overall system before delving into subsystems.
So that's going to happen.

One last thing: I intend to avoid death-by-powerpoint,
so visual aids are views of the actual working _________ system.

### Opening Performance

## Results / Data / Findings / Proof / Discussion

This section is necessarily experiential: N=1 by definition.
As such, [no true statistician](https://en.wikipedia.org/wiki/No_true_Scotsman)
should draw any definite conclusions about causality or even correlation.



## Interpretation / Significance

In retrospect, the survey reads like a curriculum. 

## Future Steps

**The Survey:**
At some point, I intend to have a reputation for being willing and able to speak on a decent variety of general-interest
software-development and comp-sci topics.
That creates a platform from which to also gather good data about needs and wants by driving traffic to a survey.

To that end, I've created a survey which I hope to adminster (currently as an appendix to this paper)
and I aim to get it into the corporate survey solution in the usual manner.
I'll soon create a brief agenda introducing the topic, opening the floor, facilitating discussion,
and then selling the idea that people please take the survey as a sanctioned contribution to the study I'm doing.

A few unconventional characteristics of the survey deserve mention:

* A more formally-designed survey might trace each question back to prior art or respected references.
  I'm relying on breadth of experience. I began with a brain-dump of everything I could think of which
  might influence the success and sustainability of a project. Then, I solicited feedback from a few
  carefully-selected, highly-trusted and qualified people to help fill any gaps.

* In the section where the respondent grades his/her project's performance,
  many of the questions include a sort of miniature rubric for how to score the issue.
  Contrary to what might be considered standard practice, I have intentionally phrased these to
  convey and promote certain value judgements about good and bad software engineering practices.
  
  I do this for several reasons which I believe are ethical, given proper expert review.
  One is to overcome apathy and stimulate action to improve matters.
  One is to overcome ignorance and stimulate a desire for learning.
  One is to overcome the assumption of agreement and stimulate focused debate on matters of substance to project success.
  
  The means and mechanism for expert review is built into the "advice and consent of the management"
  mentioned on the first screen of the survey. If I have any fundamental disagreements with management
  about what the ideal world looks like for a software engineering effort,
  then this becomes a blocking dependency.

**The Circuit:** Perhaps I need to dig more into the corporate speaking circuit.
It's entirely possible -- likely even -- that a cadre of devoted people make their living
grooming and presenting speakers.


## Conclusion

## References

## Appendix: Survey Questions

With the advice and consent of the management,
I'm trying to gather quantifiable data that will guide our future knowledge-transfer efforts.
Thank you for participating.

----

The first questions are about your personal skills and contributions to the near future of your current project.
If you lead a team, that will be on a separate screen.

1. What tool or technology would be most valuable for you to brush up on?
2. What aspect of the development life-cycle would be most valuable for you to learn more about?

----

These next questions relate to your current project. If you've recently changed projects,
please answer with respect to the project you're currently most familiar with.
I will *not* ask what project you're on. (I fear it might poison the data.)

To keep things simple, I'll ask for letter grades on each of several aspects of project execution:

* A: Excellent; exemplary.
* B: Good and respectable.
* C: Passable, but would benefit from improvement.
* D: Needs improvement badly.
* F: Fail.
* K: I am not well-enough skilled in this topic to evaluate our performance.
* N: I have no visibility into the team's performance on this topic.

----
* Mission and Vision: Does everyone know what makes this project special and worthwhile?
* Systems Thinking:
  How well do you understand the project's role within, and interface to, the larger mission and context beyond the project?
  [Thank you Margaret Hamilton.](https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer))
* The interplay between software and engineering through such topics as
  the [ACM code of professional ethics](https://www.acm.org/code-of-ethics)
  or the development of engineering ethics as a phenomenon (which is historically recent).
* Planning and Roadmap: Thinking up and evaluating possible future features or lines of development.
* Release Cadence: Do meaningful increments of business value go live regularly, or do technical obstacles slow the pace?
* Reliability: Does your product or service *just work,* or do you spend much time dealing with mistakes and breakdowns?
* Feasibility analysis:
  The economic sniff-test for each new concept, feature, or requirement.
  Accounting for the costs and high-risk hurdles that might stymie project completion,
  balancing these against viable mitigations, and roughly estimating the likely ROI on implementing.
* Procurement: Obtaining physical and logical resources on which to develop, test, or deploy the solution, service, or product.
* Deployment: Connecting, configuring, and installing the software on computing machines so that stuff physically works.
* Configuration Management: Keeping track of what versions of which artifacts are meant to be part of which release. Also, version control.
* Requirements / General:
  Is there an up-to-date, detailed, and well-organized record of what the product is meant to do and how it's meant to work,
  such that someone unfamiliar could efficiently come up to speed on any arcane aspect?
  Or do you instead rely on individuals and their falible recollections to be fonts of subject matter expertise,
  subjecting your project thereby to the hazard of someone leaving or getting hit by a truck?
* Requirements / Traceability:
  Do you have a clear and detailed picture of why each bit of your application exists and behaves as it does,
  or do you frequently wonder whether some oddity is a bug, a feature, or a vestigial relic?
* Architecture: The abstract plan to divide and conquer the overarching problem. Modular breakdown and overall approach to design.
* Design / General: Concrete *and understandable* solutions to specific, detailed subproblems: are we doing that well?
* Design / Plans and Records:
  For nontrivial problems, you probably sketched out some design notes in the process of convincing your team that an approach would work.
  Can we find those sketches or notes later when someone has a question about said design,
  or do we throw it away and have to figure it all out again when the time comes?
* Code / Organization:
  How easy or hard is it for a new person to find the modules they need to read or update?
* Code / Dragons:
  Give a bad grade if there are large sections of code that nobody knows how or why it works.
* Code / Simplicity:
  Is your project's code trivially-easy to read, understand, and modify even at a deep level,
  or does it contain lots of long, inscrutable procedures where people are afraid even to look (much less touch anything) for fear of breaking things?
* Code / Extremes:
  How would you grade the single *worst* function or module in your application, that you know about?
* Inter-Team Negotiation and Persuasion:
  For example, say your project has some new feature under development,
  which will also require Team XYZ to accomplish a task they might not otherwise do any time soon.
  How hard is it to achieve and recognize alignment on schedule and expectations between your combined sets of stakeholders?
* [Production/Operations Management](https://www.britannica.com/technology/production-management):
  In our context, I mean planning, control, execution, and administrative accountability
  for capacity, monitoring, support, and incident response.
* End-User Documentation: Can a person unfamiliar with the specifics of your product (a) figure out what to even look for, and (b) find it?
* End-User Support / Availabillity:
  Do people trivially find the help they need when they need it,
  or is it a long slog to find your inadequate homepage or contact list?
  Do new customers have to guess at how to properly request help or file a defect report?
* End-User Support / Boundaries:
  Do you clearly publish the boundaries on your scope of support?
  Have your customers understoood and agreed to these bounds?
  Does the support staff know how to say "no" when it's called for?
* End-User Support / Transparency:
  When you have a support interaction, do customers know what to expect and when, or does the squeaky wheel get the grease?
* End-User Support / Sustainability:
  Does each new customer increase your own burden? What about the overall collective burden imposed on the company stemming from that relationship?
* Operations Support: When something does go wrong, how quick and easy is it for trained personnel to notice, identify the cause, and fix the problem?
* Quality Assurance:
  Code test coverage is not enough.
  How do you know that the system does exactly what it's supposed to, even in weird rare corner cases?
* Team member professional development: Are you getting better at this job, fast enough?
* Project Control:
  Track, report, and analyze the plan, forecast, budget, schedule, scope, progress, effort, process, and changes to the above.
* Estimating:
  Business would like to know how much time, money, and effort things will take -- for business reasons.
  Do we consistently make, report, and improve these estimates on an objectively data-driven basis, unmoved by desire?
  And are they properly understood to be estimates (with a margin of uncertainty), not commmitments?
* Project Management:
  Sets goals/priorities, manages changes to scope/schedule/budget, allocates resources, and facilitates success.
  Primary focus is mission accomplishment on time, under budget, and with a satisfied customer.
* Product Management: Lives at the intersection of Business, UX, and Tech to invent, guide, and evolve the product.
  Primary focus is the grand vision and outside stakeholders.
* Intra-Team Communications: quantity, quality, tone, dignity, completeness, clarity, and frequency.
* Extra-Team Communications: quantity, quality, tone, dignity, completeness, clarity, and frequency.
* Overall Process Maturity:
  For what fraction of our activities do we consistently follow a defined process?
  Do we periodically assess and evolve, or do we shoot from the hip?
* Stress Level / Vibe:
  Do you work in a calm, motivating, and professional environment with clear sequencing,
  or do you fight fires in a culture of constant urgency where the loudest voice wins?

----

Regardless of rank or pay bracket, on your project are you:

* Team Lead
* Senior Contributor
* Junior Contributor
* Other

----

If you are a Team Lead or Senior Contributor:

1. What do your more junior colleagues most need to improve on? (Free-form)
2. Why is this?

3. On the same grading scale as before, how do you grade the overall code quality on your project?
   Do you stay tightly factored, with functional cohesion and low coupling,
   or do you have bad copy-and-mutate with interlocking temporal dependencies?
   Can you understand your code declaratively from denotational semantics,
   or does it require tricky operational reasoning?

4. Are the more junior people learning as much, and as quickly, as you'd hoped on this project?
   Not just about the project itself, but overall software engineering skill.

----

Is there anything else you'd like to share?

----

Thank you!
